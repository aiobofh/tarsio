/*
 * Tarsio Auto Mocker
 *
 *              _______          _____ ___        ______
 *                 |      ||    |         |    | |      |
 *                 |      ||    |         |    | |      |
 *                 |   ___||___ |         |___ | |______|
 *
 *                   Copyleft AiO Secure Teletronics
 *
 * This tool take a pre-processed source code (the design under test) as
 * input and replace all function calls within this file with calls to the
 * proxy-functions (or mocks if you like) that are generated by the tmg
 * tool in the Tarsio tool chain.
 */

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "debug.h"
#include "error.h"

#include "file.h"
#include "prototype.h"
#include "symbol_cache.h"

#include "version.h"

static char field[] = "$Id: tam,v " VERSION " " __DATE__ " " __TIME__ " " AUTHOR " Exp $";
static char version[] = VERSION;
static char timestamp[] = __DATE__ " " __TIME__;

/****************************************************************************
 * Program usage
 */
static void usage(const char* program_name)
{
  printf("USAGE: %s <cache-file> <pre-processed-source>\n", program_name);
}

/****************************************************************************
 * Program version
 */
static void ver(const char* program_name) {
  printf("%s v%s %s (%s)\n", program_name, version, timestamp, field);
}

/****************************************************************************
 * Option handling
 */
struct tam_options_s {
  char* cache_filename;
  char* source_filename;
};
typedef struct tam_options_s tam_options_t;

static int tam_options_init(tam_options_t* options, int argc, char* argv[])
{
  if (argc == 2) {
    if ((0 == strcmp("-v", argv[1])) || (0 == strcmp("--version", argv[1])) || (0 == strcmp("VERSION", argv[1]))) {
      ver(argv[0]);
      return -1;
    }
    if ((0 == strcmp("-h", argv[1])) || (0 == strcmp("--help", argv[1])) || (0 == strcmp("?", argv[1]))) {
      usage(argv[0]);
      return -1;
    }
  }

  if (argc != 3) {
    error1("ERROR: Illegal number (%d) of arguments", argc);
    usage(argv[0]);
    return -1;
  }

  options->cache_filename = argv[1];
  options->source_filename = argv[2];

  return 0;
}

/*
size_t first_func_offset(prototype_list_t* list) {
  prototype_node_t* node;

  return list->first_function_implementation_offset;

  for (node = list->first; NULL != node; node = node->next) {
    fprintf(stderr, "DEBUG: '%s'\n", node->info.symbol);
    if (node->info.is_function_implementation) {
      fprintf(stderr, "DEBUG: First function found %lu\n", node->info.raw_prototype.offset);
      fprintf(stderr, "First func offset %lu\n", node->info.raw_prototype.offset);
      return node->info.raw_prototype.offset;
    }
  }
  fprintf(stderr, "ERROR: No first function found\n");
  return 0;
}
*/

enum sort_search_e {
  SEARCH_NONE,
  SEARCH_FIRST_FUNCTION,
  SEARCH_FUNCTION_HEAD,
  SEARCH_STATIC_FUNCTION,
  SEARCH_FUNCTION_CALL
};
typedef enum sort_search_e sort_search_t;

struct replace_node_s {
  struct replace_node_s* prev;
  prototype_node_t* prototype_node;
  symbol_usage_node_t* symbol_usage_node;
  int only_static;
  sort_search_t search;
  size_t offset;
  size_t line;
  size_t column;
  struct replace_node_s* next;
};
typedef struct replace_node_s replace_node_t;

struct replace_list_s {
  replace_node_t* first;
  replace_node_t* last;
};
typedef struct replace_list_s replace_list_t;

static void generate_extern_proxy_prototype(prototype_list_t* list, const size_t offset, replace_node_t* node) {
  symbol_usage_node_t* snode = node->symbol_usage_node;

  generate_prototype(snode->info.prototype_node, "extern ", "__tarsio_proxy_", ";");
  snode->info.last_function_start = 0; /* Never declare this one again */

  return;


  /* I wonder if this works in all compilers :D */
  /*
  for (node = list->first; NULL != node; node = node->next) {
    fprintf(stderr, "DEBUG: %s %p\n", node->info.symbol, node->info.symbol_usage_list.first);

    symbol_usage_list_t* slist = &node->info.symbol_usage_list;
    symbol_usage_node_t* snode;
    for (snode = slist->first; NULL != snode; snode = snode->next) {

      fprintf(stderr, "DEBUG: is %lu == %lu\n",
              snode->info.last_function_start, offset);

      if (offset == snode->info.last_function_start) {
        fprintf(stderr, "DEBUG: Yes\n");
        generate_prototype(node, "extern ", "__tarsio_proxy_", ";");
        snode->info.last_function_start = 0;
      }
    }
  }
  printf("\n");
  */
}

/*
static void generate_extern_proxy_prototypes(prototype_list_t* list) {
  prototype_node_t* node;
  for (node = list->first; NULL != node; node = node->next) {
    generate_prototype(node, "extern ", "__tarsio_proxy_", ";");
  }
  printf("\n");
}
*/


/*
static replace_node_t* search_first_function(replace_list_t* list,
                                             size_t first_func_offset)
{
  replace_node_t* node;
  for (node = list->first; NULL != node; node = node->next) {
    if (first_func_offset < node->offset) {
      break;
    }
  }
  return node;
}
*/

static replace_node_t* search_static_function(replace_list_t* list,
                                              prototype_node_t* pnode)
{
  replace_node_t* node;
  for (node = list->first; NULL != node; node = node->next) {
    fprintf(stderr, "DEBUG: static func %lu < %lu (%s) %d?\n", pnode->info.raw_prototype.offset, node->offset, node->prototype_node->info.symbol, node->search);
    if (pnode->info.raw_prototype.offset < node->offset) {
      fprintf(stderr, "DEBUG:   Found it %lu < %lu\n", pnode->info.raw_prototype.offset, node->offset);
      return node;
    }
  }
  return NULL;
}

static replace_node_t* search_function_call(replace_list_t* list,
                                            symbol_usage_node_t* snode)
{
  replace_node_t* node;
  prototype_node_t* p;
  debug0("Searching for function calls to replaced functions");
  for (node = list->first; NULL != node; node = node->next) {
    p = (prototype_node_t*)snode->info.prototype_node;
    fprintf(stderr, "DEBUG: func %s call %lu < %lu (%s) %d?\n", p->info.symbol, snode->info.offset, node->offset, node->prototype_node->info.symbol, node->search);
    // if (snode->info.last_function_start < node->offset) {
    if (snode->info.offset < node->offset) {
      fprintf(stderr, "DEBUG:   Found it %lu < %lu\n", snode->info.offset, node->offset);
      return node;
    }
  }
  return NULL;
}

static replace_node_t* search_function_head(replace_list_t* list,
                                            symbol_usage_node_t* snode)
{
  replace_node_t* node;
  for (node = list->first; NULL != node; node = node->next) {
    fprintf(stderr, "DEBUG: func head %lu < %lu (%s) %d?\n", snode->info.offset, node->offset, node->prototype_node->info.symbol, node->search);
    // if (snode->info.offset < node->offset) {
    if (snode->info.last_function_start < node->offset) {
      fprintf(stderr, "DEBUG:   Found it %lu < %lu\n", snode->info.offset, node->offset);
      return node;
    }
  }
  return NULL;
}

static replace_node_t* new_replace_node(prototype_node_t* pnode,
                                        symbol_usage_node_t* snode,
                                        sort_search_t search)
{
  replace_node_t* node;

  if (NULL == (node = malloc(sizeof(*node)))) {
    error1("Out of memory while sorting usage list for '%s'",
           pnode->info.symbol);
    return NULL;
  }

  node->prev = node->next = NULL;
  node->prototype_node = pnode;
  node->symbol_usage_node = snode;
  node->search = search;
  node->offset = 0;
  if (NULL != pnode) {
    fprintf(stderr, "DEBUG: Grabbing line and column from pnode\n");
    node->line = pnode->info.raw_prototype.line;
    node->column = pnode->info.raw_prototype.column;
  }
  else if (NULL != snode) {
    fprintf(stderr, "DEBUG: Grabbing line and column from snode\n");
    node->line = snode->info.line;
    node->column = snode->info.col;
  }

  return node;
}

static void replace_list_add(replace_list_t* list,
                             replace_node_t* node,
                             replace_node_t* new_node)
{
  if (NULL == list->first) {
    list->first = new_node;
  }

  if (NULL == node) {
    if (NULL != list->last) {
      fprintf(stderr, "DEBUG: ---- Adding node %s last in list (offset %lu)\n", new_node->prototype_node->info.symbol, new_node->offset);
      list->last->next = new_node;
    }
    new_node->prev = list->last;
    list->last = new_node;
  }
  else {
    replace_node_t* prev = node->prev;

    if (NULL == prev) {
      list->first = new_node;
      fprintf(stderr, "DEBUG: ---- Inserting node %s first in list (offset %lu before %lu)\n", new_node->prototype_node->info.symbol, new_node->offset, node->offset);
    }
    else {
      fprintf(stderr, "DEBUG: ---- Inserting node %s in list (offset %lu between %lu and %lu)\n", new_node->prototype_node->info.symbol, new_node->offset, node->offset, prev->offset);
      prev->next = new_node;
    }
    node->prev = new_node;
    new_node->prev = prev;
    new_node->next = node;
  }
}

/*
static int insert_first_function_offset(replace_list_t* list,
                                        size_t offset)
{
  replace_node_t* new_node;
  replace_node_t* node;
  new_node = new_replace_node(NULL, NULL, SEARCH_FIRST_FUNCTION);
  if (NULL == new_node) {
    error0("Unable to create new sorted usage node");
    return -1;
  }

  node = search_first_function(list, offset);

  new_node->offset = offset;

  replace_list_add(list, node, new_node);

  return 0;
}
*/

static int insert_static_function_offset(replace_list_t* list,
                                         prototype_node_t* pnode)
{
  replace_node_t* new_node;
  replace_node_t* node;
  new_node = new_replace_node(pnode, NULL, SEARCH_STATIC_FUNCTION);
  if (NULL == new_node) {
    error0("Unable to create new sorted usage node");
    return -1;
  }

  node = search_static_function(list, pnode);

  new_node->offset = pnode->info.raw_prototype.offset;

  debug4(" Adding node \"%s\" static to replace list line: %lu column %lu (offset: %lu)", pnode->info.symbol, new_node->line, new_node->column, new_node->offset);

  replace_list_add(list, node, new_node);

  return 0;
}

static int insert_function_call_offset(replace_list_t* list,
                                       prototype_node_t* pnode,
                                       symbol_usage_node_t* snode)
{
  replace_node_t* new_node;
  replace_node_t* node;
  new_node = new_replace_node(pnode, snode, SEARCH_FUNCTION_CALL);
  if (NULL == new_node) {
    error0("Unable to create new sorted usage node");
    return -1;
  }

  node = search_function_call(list, snode);

  new_node->offset = snode->info.offset - strlen(pnode->info.symbol);

  debug4(" Adding node \"%s\" call to replace list line: %lu column %lu (offset: %lu)", pnode->info.symbol, new_node->line, new_node->column, new_node->offset);

  replace_list_add(list, node, new_node);

  return 0;
}

static int insert_calling_function_head_offset(replace_list_t* list,
                                               prototype_node_t* pnode,
                                               symbol_usage_node_t* snode)
{
  replace_node_t* new_node;
  replace_node_t* node;

  if (0 == snode->info.last_function_start) {
    fprintf(stderr, "DEBUG: No position\n");
    return 0;
  }
  new_node = new_replace_node(pnode, snode, SEARCH_FUNCTION_HEAD);
  if (NULL == new_node) {
    error0("Unable to create new sorted usage node");
    return -1;
  }

  node = search_function_head(list, snode);

  new_node->offset = snode->info.last_function_start;

  debug4(" Adding node \"%s\" extern to replace list line: %lu column %lu (offset: %lu)", pnode->info.symbol, new_node->line, new_node->column, new_node->offset);

  replace_list_add(list, node, new_node);

  return 0;
}

static int sort_usage(replace_list_t* slist, prototype_list_t* plist) {
  prototype_node_t* pnode;
  /*
  size_t first_func_offs = first_func_offset(plist);
  */
  /*
   * First add the offset to the first function found in the pre-processsed
   * source code version of the design under test, because this is a good
   * place to insert extern declarations to all the proxified versions that
   * are generated in another file.
   */

  /*
  insert_first_function_offset(slist, first_func_offs);
  */

  /*
   * Lastly add offsets to all the usage (function calls) to any function
   * that is supposed to have a generated proxy function. This is the actual
   * auto-mocking consequence. ALWAYS making sure that the design under test
   * use the proxy functions instead of the real functions.
   */

  for (pnode = plist->first; NULL != pnode; pnode = pnode->next) {
    debug1("Finding offset where to put the declaration for %s", pnode->info.symbol);
    symbol_usage_list_t* sl = &pnode->info.symbol_usage_list;
    symbol_usage_node_t* sn;
    for (sn = sl->first; NULL != sn; sn = sn->next) {
      debug3("  line: %lu column: %lu (offset: %lu)", sn->info.line, sn->info.col, sn->info.offset);
      if (insert_calling_function_head_offset(slist, pnode, sn)) {
        error0("Could not insert");
        return -1;
      }

      if (insert_function_call_offset(slist, pnode, sn)) {
        error0("Could not insert");
        return -1;
      }
    }
  }

  /*
   * Then add offets to all the statically declared functions in the pre-
   * processed source code version of the design under test, because these
   * must be made global instead of static in the output file, so that all
   * the modal functions in the design under test can be called from the
   * testcases.
   */

  for (pnode = plist->first; NULL != pnode; pnode = pnode->next) {
    if (pnode->info.linkage_definition.is_static) {
      debug1("Finding offset where to put the static declaration for %s", pnode->info.symbol);
      if (0 != insert_static_function_offset(slist, pnode)) {
        error0("Could not insert");
        return -1;
      }
    }
  }

  return 0;
}

void declarations_at_offset(prototype_list_t* list, const size_t insert_offset) {
  prototype_node_t* node;
  if (0 == insert_offset) {
    return;
  }
  for (node = list->first; NULL != node; node = node->next) {
    symbol_usage_list_t* slist = &node->info.symbol_usage_list;
    symbol_usage_node_t* snode;
    for (snode = slist->first; NULL != snode; snode = snode->next) {
      if (insert_offset == snode->info.last_function_start) {
        fprintf(stderr, "DEBUG: Should need to insert '%s' at %lu\n",
                node->info.symbol, insert_offset);
      }
    }
  }
}

static void generate_proxified(prototype_list_t* list, file_t* file) {
  /*
   * Replicate the pre-processed C code version and replace all function
   * calls with proxies, and also declare them extern right above the first
   * invoking function definition.
   */
  replace_list_t slist;
  replace_node_t* node;
  size_t offset = 0;
  size_t line = 0;
  slist.first = slist.last = NULL;
  if (0 != sort_usage(&slist, list)) {
    error0("Out of memory while sorting usage list\n");
    return;
  }

  for (node = slist.first; NULL != node; node = node->next) {
    fprintf(stderr, "CHUNK %lu-%lu\n", offset, node->offset);
    offset = node->offset;
  }

  offset = 0;
  line = 0;

  node = slist.first;
  while (offset < file->len) {
    if (NULL == node) {
      /* Write the rest of the file and exit */
      fwrite(&file->buf[offset], file->len - offset, 1, stdout);
      debug2("Writing %lu bytes chunk line %lu to end (file end)", file->len - offset, line);
      break;
    }
    else if (SEARCH_FUNCTION_HEAD == node->search) {
      fwrite(&file->buf[offset], node->offset - offset, 1, stdout);
      debug6("Writing %lu %lu %lu bytes chunk line %lu-%lu (before function head exetern %s)", offset, node->offset, node->offset - offset, line, node->line, node->prototype_node->info.symbol);
      generate_extern_proxy_prototype(list, offset, node);
      offset = node->offset;
      line = node->line;
    }
    else if (SEARCH_STATIC_FUNCTION == node->search) {
      /* Output all file contents since last offset increase */
      fwrite(&file->buf[offset], node->offset - offset, 1, stdout);
      debug6("Writing %lu %lu %lu bytes chunk line %lu-%lu (before static removal static %s)", offset, node->offset, node->offset - offset, line, node->line, node->prototype_node->info.symbol);
      offset = node->offset + strlen("static ") + 1;
      line = node->line;
    }
    else if (SEARCH_FUNCTION_CALL == node->search) {
      /* Output all file contents since last offset increase */
      fwrite(&file->buf[offset], node->offset - offset, 1, stdout);
      debug6("Writing %lu %lu %lu bytes chunk line %lu-%lu (before function call __tarsio_proxy %s)", offset, node->offset, node->offset - offset, line, node->line, node->prototype_node->info.symbol);
      printf("__tarsio_proxy_");
      offset = node->offset;
      line = node->line;
    }
    else {
      error0("This should never happen");
      exit(1);
    }
    node = node->next;
  }

  return;

  node = slist.first;
  while (offset <= file->len) {
    if (NULL == node) {
      /* Write the rest of the file and exit */
      fwrite(&file->buf[offset], file->len - offset, 1, stdout);
      break;
    }
    else if (SEARCH_FUNCTION_HEAD == node->search) {
      /* TODO: This fucks up the line-numbering in the pre-processed file
       *       when using GCC and others, since it inserts lines right
       *       above the first usage of a proxyable function to have the
       *       extern declarations of the proxy function declared before
       *       the function call */
      fprintf(stderr, "DEBUG: making som extern function before line: %lu column: %lu (offset %lu)\n", node->line, node->column, node->offset);
      generate_extern_proxy_prototype(list, offset, node);
      if (node->next && node->next->offset != node->offset) {
        fwrite(&file->buf[offset], node->next->offset - offset, 1, stdout);
        offset = node->next->offset;
      }
      /*
      fwrite(&file->buf[offset], node->offset - offset, 1, stdout);
      */
      /*
      offset = node->offset;
      */
    }
    /*
    else if (SEARCH_FIRST_FUNCTION == node->search) {
      fprintf(stderr, "DEBUG: About to inser texterns %lu\n", node->offset);
      while ('\n' != file->buf[node->offset]) {
        fprintf(stderr, "DEBUG: '%c'\n", file->buf[node->offset]);
        node->offset--;
      }

      fwrite(&file->buf[offset], node->offset - offset, 1, stdout);
      generate_extern_proxy_prototypes(list);
      offset = node->offset;
    }
    */
    else if (SEARCH_STATIC_FUNCTION == node->search) {
      /* Skip the 'static' keyword, so that all functions are callable from
       * the checks. */
      fprintf(stderr, "DEBUG: Stripping static at line: %lu column: %lu (offset %lu)\n", node->line, node->column, node->offset);
      fprintf(stderr, "DEBUG:   offset: %lu\n", offset);
      fprintf(stderr, "DEBUG:   node->offset: %lu\n", node->offset);
      fprintf(stderr, "DEBUG:   node->offset - offset: %lu\n", node->offset - offset);
      fprintf(stderr, "DEBUG:   node->offset + strlen(\"static \") + 1 = %lu\n", node->offset + strlen("static ") + 1);
      fwrite(&file->buf[offset], node->offset - offset, 1, stdout);
      offset = node->offset + strlen("static ") + 1;
    }
    else if (SEARCH_FUNCTION_CALL == node->search) {
      /* Prefix _all_ function calls to known functions with the tarsio proxy
       * prefix - So that we can be sure no real code is called directly, at
       * least not without passing via the proxy function. */

      fwrite(&file->buf[offset], node->offset - offset, 1, stdout);

      printf("__tarsio_proxy_");
      offset = node->offset;
    }
    else {
      error0("No search type should never happen :)");
      return;
    }

    node = node->next;
  }

  return;
}

/****************************************************************************
 * Program
 */
int main(int argc, char* argv[])
{
  int retval = EXIT_SUCCESS;
  tam_options_t options;
  file_t source_file = FILE_EMPTY;
  prototype_list_t prototype_list = PROTOTYPE_LIST_EMPTY;

  /*
   * Handle arguments passed to the program.
   */
  if (0 != tam_options_init(&options, argc, argv)) {
    retval = EXIT_FAILURE;
    goto options_init_failed;
  }

  /*
   * Read the pre-processed version of the design under test
   */
  if (0 != file_init(&source_file, options.source_filename)) {
    retval = EXIT_FAILURE;
    goto read_preprocessed_file_failed;
  }
  reload_symbol_cache(&prototype_list, options.cache_filename);

  /*
   * Generate a new version of the pre-processed input but with extern
   * declarations to all used function proxies, and replaced function
   * usage.
   */
  generate_proxified(&prototype_list, &source_file);

 read_preprocessed_file_failed:
 options_init_failed:
  return retval;
}
