/*
 * Tarsio Auto Mocker
 *
 *              _______          _____ ___        ______
 *                 |      ||    |         |    | |      |
 *                 |      ||    |         |    | |      |
 *                 |   ___||___ |         |___ | |______|
 *
 *            Copyright (C) 2020-2022 AiO Secure Teletronics
 *
 * This tool take a pre-processed source code (the design under check) as
 * input and replace all function calls within this file with calls to the
 * proxy-functions (or mocks if you like) that are generated by the tmg
 * tool in the Tarsio tool chain.
 *
 *  This file is part of Tarsio.
 *
 *  Tarsio is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  Tarsio is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with Tarsio.  If not, see <https://www.gnu.org/licenses/>.
 *
 */

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "debug.h"
#include "error.h"
#include "options.h"

#include "file.h"
#include "prototype.h"
#include "symbol_cache.h"

#include "version.h"

static char field[] = "$Id: tam,v " VERSION " " __DATE__ " " __TIME__ " " AUTHOR " Exp $";
static char version[] = VERSION;
static char timestamp[] = __DATE__ " " __TIME__;

int __tarsio_debug_print = 0;

/****************************************************************************
 * Program usage
 */
static void usage(const char* program_name)
{
  printf("USAGE: %s <cache-file> <pre-processed-source> <struct-header>\n", program_name);
}

/****************************************************************************
 * Program version
 */
static void ver(const char* program_name) {
  printf("%s v%s %s (%s)\n", program_name, version, timestamp, field);
}

/****************************************************************************
 * Option handling
 */
struct tam_options_s {
  char* cache_filename;
  char* source_filename;
};
typedef struct tam_options_s tam_options_t;

static int tam_options_init(tam_options_t* options, int argc, char* argv[])
{
  int rest;
  options_t tam_options[3] = { {'v', "version", "VERSION", NULL, 0 },
                               {'h', "help", "?", NULL, 0 },
                               {'d', "debug", "DEBUG", NULL, 0 } };

  if (0 > (rest = options_init(argc, argv, tam_options, 3))) {
    usage(argv[0]);
    return -1;
  }

  if (tam_options[0].enabled) {
    ver(argv[0]);
    return -1;
  }
  if (tam_options[1].enabled) {
    usage(argv[0]);
    return -1;
  }
  if (tam_options[2].enabled) {
    __tarsio_debug_print = 1;
  }

  if ((argc - rest) != 4) {
    error2("ERROR: Illegal number (%d) of arguments (%d)", argc, (argc - rest));
    usage(argv[0]);
    return -1;
  }

  options->cache_filename = argv[rest + 1];
  options->source_filename = argv[rest + 2];

  return 0;
}

enum sort_search_e {
  SEARCH_NONE,
  SEARCH_FIRST_FUNCTION,
  SEARCH_FUNCTION_HEAD,
  SEARCH_STATIC_FUNCTION,
  SEARCH_FUNCTION_CALL
};
typedef enum sort_search_e sort_search_t;

struct replace_node_s {
  struct replace_node_s* prev;
  prototype_node_t* prototype_node;
  symbol_usage_node_t* symbol_usage_node;
  int only_static;
  sort_search_t search;
  size_t offset;
  size_t line;
  size_t column;
  struct replace_node_s* next;
};
typedef struct replace_node_s replace_node_t;

struct replace_list_s {
  replace_node_t* first;
  replace_node_t* last;
};
typedef struct replace_list_s replace_list_t;

static void generate_extern_proxy_prototype(prototype_list_t* list, const size_t offset, replace_node_t* node) {
  symbol_usage_node_t* snode = node->symbol_usage_node;

  generate_prototype(snode->info.prototype_node, "extern ", "__tarsio_proxy_", ";");
  snode->info.last_function_start = 0; /* Never declare this one again */
}

static replace_node_t* search_static_function(replace_list_t* list,
                                              prototype_node_t* pnode)
{
  replace_node_t* node;
  for (node = list->first; NULL != node; node = node->next) {
    if (pnode->info.raw_prototype.offset < node->offset) {
      return node;
    }
  }
  return NULL;
}

static replace_node_t* search_function_call(replace_list_t* list,
                                            symbol_usage_node_t* snode)
{
  replace_node_t* node;
  for (node = list->first; NULL != node; node = node->next) {
    if (snode->info.offset < node->offset) {
      return node;
    }
  }
  return NULL;
}

static replace_node_t* search_function_head(replace_list_t* list,
                                            symbol_usage_node_t* snode)
{
  replace_node_t* node;
  for (node = list->first; NULL != node; node = node->next) {
    if (snode->info.last_function_start < node->offset) {
      return node;
    }
  }
  return NULL;
}

static replace_node_t* new_replace_node(prototype_node_t* pnode,
                                        symbol_usage_node_t* snode,
                                        sort_search_t search)
{
  replace_node_t* node;

  if (NULL == (node = malloc(sizeof(*node)))) {
    error1("Out of memory while sorting usage list for '%s'",
           pnode->info.symbol);
    return NULL;
  }

  node->prev = node->next = NULL;
  node->prototype_node = pnode;
  node->symbol_usage_node = snode;
  node->search = search;
  node->offset = 0;
  if (NULL != pnode) {
    node->line = pnode->info.raw_prototype.line;
    node->column = pnode->info.raw_prototype.column;
  }
  else if (NULL != snode) {
    node->line = snode->info.line;
    node->column = snode->info.col;
  }

  return node;
}

static void replace_list_add(replace_list_t* list,
                             replace_node_t* node,
                             replace_node_t* new_node)
{
  if (NULL == list->first) {
    list->first = new_node;
  }

  if (NULL == node) {
    if (NULL != list->last) {
      list->last->next = new_node;
    }
    new_node->prev = list->last;
    list->last = new_node;
  }
  else {
    replace_node_t* prev = node->prev;

    if (NULL == prev) {
      list->first = new_node;
    }
    else {
      prev->next = new_node;
    }
    node->prev = new_node;
    new_node->prev = prev;
    new_node->next = node;
  }
}

static int insert_static_function_offset(replace_list_t* list,
                                         prototype_node_t* pnode)
{
  replace_node_t* new_node;
  replace_node_t* node;
  new_node = new_replace_node(pnode, NULL, SEARCH_STATIC_FUNCTION);
  if (NULL == new_node) {
    error0("Unable to create new sorted usage node");
    return -1;
  }

  node = search_static_function(list, pnode);

  new_node->offset = pnode->info.raw_prototype.offset;

  debug4(" Adding node \"%s\" static to replace list line: %lu column %lu (offset: %lu)", pnode->info.symbol, new_node->line, new_node->column, new_node->offset);

  replace_list_add(list, node, new_node);

  return 0;
}

static int insert_function_call_offset(replace_list_t* list,
                                       prototype_node_t* pnode,
                                       symbol_usage_node_t* snode)
{
  replace_node_t* new_node;
  replace_node_t* node;
  new_node = new_replace_node(pnode, snode, SEARCH_FUNCTION_CALL);
  if (NULL == new_node) {
    error0("Unable to create new sorted usage node");
    return -1;
  }

  node = search_function_call(list, snode);

  new_node->offset = snode->info.offset - strlen(pnode->info.symbol);

  debug4(" Adding node \"%s\" call to replace list line: %lu column %lu (offset: %lu)", pnode->info.symbol, new_node->line, new_node->column, new_node->offset);

  replace_list_add(list, node, new_node);

  return 0;
}

static int insert_calling_function_head_offset(replace_list_t* list,
                                               prototype_node_t* pnode,
                                               symbol_usage_node_t* snode)
{
  replace_node_t* new_node;
  replace_node_t* node;

  if (0 == snode->info.last_function_start) {
    return 0;
  }
  new_node = new_replace_node(pnode, snode, SEARCH_FUNCTION_HEAD);
  if (NULL == new_node) {
    error0("Unable to create new sorted usage node");
    return -1;
  }

  node = search_function_head(list, snode);

  new_node->offset = snode->info.last_function_start;

  debug4(" Adding node \"%s\" extern to replace list line: %lu column %lu (offset: %lu)", pnode->info.symbol, new_node->line, new_node->column, new_node->offset);

  replace_list_add(list, node, new_node);

  return 0;
}

static int sort_usage(replace_list_t* slist, prototype_list_t* plist) {
  prototype_node_t* pnode;
  /*
   * First add offsets to all the usage (function calls) to any function
   * that is supposed to have a generated proxy function. This is the actual
   * auto-mocking consequence. ALWAYS making sure that the design under check
   * use the proxy functions instead of the real functions.
   */

  for (pnode = plist->first; NULL != pnode; pnode = pnode->next) {
    symbol_usage_list_t* sl = &pnode->info.symbol_usage_list;
    symbol_usage_node_t* sn;
    debug1("Finding offset where to put the declaration for %s", pnode->info.symbol);
    for (sn = sl->first; NULL != sn; sn = sn->next) {
      debug3("  line: %lu column: %lu (offset: %lu)", sn->info.line, sn->info.col, sn->info.offset);
      if (insert_calling_function_head_offset(slist, pnode, sn)) {
        error0("Could not insert");
        return -1;
      }

      if (insert_function_call_offset(slist, pnode, sn)) {
        error0("Could not insert");
        return -1;
      }
    }
  }

  /*
   * Then add offets to all the statically declared functions in the pre-
   * processed source code version of the design under check, because these
   * must be made global instead of static in the output file, so that all
   * the modal functions in the design under check can be called from the
   * checkcases.
   */
  for (pnode = plist->first; NULL != pnode; pnode = pnode->next) {
    if (pnode->info.linkage_definition.is_static) {
      debug1("Finding offset where to put the static declaration for %s", pnode->info.symbol);
      if (0 != insert_static_function_offset(slist, pnode)) {
        error0("Could not insert");
        return -1;
      }
    }
  }

  return 0;
}

static int grab_info_from_line_marker(const char* buf, char* filename, const size_t len, char* fmt) {
  char numbuf[10];
  const char* bufstart = buf;
  char* ptr = numbuf;
  char* fptr = filename;
  int retval = -1;
  memset(numbuf, 0, sizeof(numbuf));
  memset(fmt, 0, len);
  memset(filename, 0, len);
  while ('\n' != *buf) {
    if ('"' == *buf) {
      buf++;
      while ('"' != *buf) {
        *fptr = *buf;
        fptr++;
        buf++;
      }
      if (retval != -1) {
        break;
      }
    }
    else if (('0' <= *buf) && ('9' >= *buf)) {
      while (('0' <= *buf) && ('9' >= *buf)) {
        *ptr = *buf;
        buf++;
        ptr++;
      }
      retval = atoi(numbuf);
    }
    buf++;
  }
  while (bufstart < buf + 1) {
    if (('0' <= *bufstart) && ('9' >= *bufstart)) {
      while (('0' <= *bufstart) && ('9' >= *bufstart)) {
        bufstart++;
      }
      *fmt = '%';
      fmt++;
      *fmt = 'd';
      fmt++;
    }
    *fmt = *bufstart;
    fmt++;
    bufstart++;
  }
  return retval;
}

static void copy_previous_line_directive(const char* buf, size_t offset) {
  /* This is not a function to be proud of. Solves the problem. REFACTOR! */
  char out[1000];
  size_t line_offset = -2;
  size_t end_offset = offset;
  while ((0 < offset) || (end_offset - offset > sizeof(out))) {
    switch (buf[offset]) {
    case '\n':
      line_offset++;
      end_offset = offset;
      break;
    case '#':
      /*
      if (((buf[offset + 1] == ' ') && ((buf[offset + 2] >= '0') && (buf[offset + 2] <= '9'))) || (0 == strncmp("#line ", &buf[offset], 6))) {
      */
      if (((buf[offset + 1] == ' ') && ((buf[offset + 2] >= '0') && (buf[offset + 2] <= '9')))) {
        char filename[1000];
        char fmt[1000];
        size_t last_line_directive_line = 0;
        strncpy(out, &buf[offset], end_offset - offset);
        last_line_directive_line = grab_info_from_line_marker(out, filename, end_offset - offset, fmt);
        fprintf(stdout, fmt, last_line_directive_line + line_offset);
        putc('\n', stdout);
        return;
      }
      break;
    }
    offset--;
  }
}

static void generate_proxified(prototype_list_t* list, file_t* file) {
  /*
   * Replicate the pre-processed C code version and replace all function
   * calls with proxies, and also declare them extern right above the first
   * invoking function definition.
   */
  replace_list_t slist;
  replace_node_t* node;
  size_t offset;
  slist.first = slist.last = NULL;

  if (0 != sort_usage(&slist, list)) {
    error0("Out of memory while sorting usage list\n");
    return;
  }

  for (node = slist.first; NULL != node; node = node->next) {
    offset = node->offset;
  }

  offset = 0;

  node = slist.first;
  while (offset < file->len) {
    if (NULL == node) {
      /* Write the rest of the file and exit */
      fwrite(&file->buf[offset], file->len - offset, 1, stdout);
      debug1("Writing %lu bytes chunk to end (file end)", file->len - offset);
      break;
    }
    else if (SEARCH_FUNCTION_HEAD == node->search) {
      fwrite(&file->buf[offset], node->offset - offset, 1, stdout);
      debug4("Writing %lu %lu %lu bytes chunk (before function head exetern %s)", offset, node->offset, node->offset - offset, node->prototype_node->info.symbol);
      printf("\n");
      generate_extern_proxy_prototype(list, offset, node);
#ifdef __GNUC__
      copy_previous_line_directive(file->buf, offset);
#endif
      offset = node->offset;
    }
    else if (SEARCH_STATIC_FUNCTION == node->search) {
      /* Output all file contents since last offset increase */
      fwrite(&file->buf[offset], node->offset - offset, 1, stdout);
      debug4("Writing %lu %lu %lu bytes chunk (before static removal static %s)", offset, node->offset, node->offset - offset, node->prototype_node->info.symbol);
      offset = node->offset + strlen("static ") + 1;
    }
    else if (SEARCH_FUNCTION_CALL == node->search) {
      /* Output all file contents since last offset increase */
      fwrite(&file->buf[offset], node->offset - offset, 1, stdout);
      debug4("Writing %lu %lu %lu bytes chunk (before function call __tarsio_proxy %s)", offset, node->offset, node->offset - offset, node->prototype_node->info.symbol);
      printf("__tarsio_proxy_");
      offset = node->offset;
    }
    else {
      error0("This should never happen");
      exit(1);
    }
    node = node->next;
  }
}

/****************************************************************************
 * Program
 */
int main(int argc, char* argv[])
{
  int retval = EXIT_SUCCESS;
  tam_options_t options;
  file_t source_file = FILE_EMPTY;
  prototype_list_t prototype_list = PROTOTYPE_LIST_EMPTY;
  unsigned char* buf;

  /*
   * Handle arguments passed to the program.
   */
  if (0 != tam_options_init(&options, argc, argv)) {
    retval = EXIT_FAILURE;
    goto options_init_failed;
  }

  /*
   * Read the pre-processed version of the design under check
   */
  if (0 != file_init(&source_file, options.source_filename)) {
    retval = EXIT_FAILURE;
    goto read_preprocessed_file_failed;
  }
  buf = reload_symbol_cache(&prototype_list, options.cache_filename);

  /*
   * Generate a new version of the pre-processed input but with extern
   * declarations to all used function proxies, and replaced function
   * usage.
   */
  generate_proxified(&prototype_list, &source_file);

  file_cleanup(&source_file);
  if (NULL != buf) {
    free(buf);
  }
 read_preprocessed_file_failed:
 options_init_failed:
  return retval;
}
