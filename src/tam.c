/*
 * Tarsio Auto Mocker
 *
 *              _______          _____ ___        ______
 *                 |      ||    |         |    | |      |
 *                 |      ||    |         |    | |      |
 *                 |   ___||___ |         |___ | |______|
 *
 *                   Copyleft AiO Secure Teletronics
 *
 * This tool take a pre-processed source code (the design under test) as
 * input and replace all function calls within this file with calls to the
 * proxy-functions (or mocks if you like) that are generated by the tmg
 * tool in the Tarsio tool chain.
 */

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "debug.h"
#include "error.h"

#include "file.h"
#include "prototype.h"
#include "symbol_cache.h"

#include "version.h"

static char field[] = "$Id: tam,v " VERSION " " __DATE__ " " __TIME__ " " AUTHOR " Exp $";
static char version[] = VERSION;
static char timestamp[] = __DATE__ " " __TIME__;

/****************************************************************************
 * Program usage
 */
static void usage(const char* program_name)
{
  printf("USAGE: %s <cache-file> <pre-processed-source>\n", program_name);
}

/****************************************************************************
 * Program version
 */
static void ver(const char* program_name) {
  printf("%s v%s %s (%s)\n", program_name, version, timestamp, field);
}

/****************************************************************************
 * Option handling
 */
struct tam_options_s {
  char* cache_filename;
  char* source_filename;
};
typedef struct tam_options_s tam_options_t;

static int tam_options_init(tam_options_t* options, int argc, char* argv[])
{
  if (argc == 2) {
    if ((0 == strcmp("-v", argv[1])) || (0 == strcmp("--version", argv[1])) || (0 == strcmp("VERSION", argv[1]))) {
      ver(argv[0]);
      return -1;
    }
    if ((0 == strcmp("-h", argv[1])) || (0 == strcmp("--help", argv[1])) || (0 == strcmp("?", argv[1]))) {
      usage(argv[0]);
      return -1;
    }
  }

  if (argc != 3) {
    error1("ERROR: Illegal number (%d) of arguments", argc);
    usage(argv[0]);
    return -1;
  }

  options->cache_filename = argv[1];
  options->source_filename = argv[2];

  return 0;
}

enum sort_search_e {
  SEARCH_NONE,
  SEARCH_FIRST_FUNCTION,
  SEARCH_FUNCTION_HEAD,
  SEARCH_STATIC_FUNCTION,
  SEARCH_FUNCTION_CALL
};
typedef enum sort_search_e sort_search_t;

struct replace_node_s {
  struct replace_node_s* prev;
  prototype_node_t* prototype_node;
  symbol_usage_node_t* symbol_usage_node;
  int only_static;
  sort_search_t search;
  size_t offset;
  size_t line;
  size_t column;
  struct replace_node_s* next;
};
typedef struct replace_node_s replace_node_t;

struct replace_list_s {
  replace_node_t* first;
  replace_node_t* last;
};
typedef struct replace_list_s replace_list_t;

static void generate_extern_proxy_prototype(prototype_list_t* list, const size_t offset, replace_node_t* node) {
  symbol_usage_node_t* snode = node->symbol_usage_node;

  generate_prototype(snode->info.prototype_node, "extern ", "__tarsio_proxy_", ";");
  snode->info.last_function_start = 0; /* Never declare this one again */
}

static replace_node_t* search_static_function(replace_list_t* list,
                                              prototype_node_t* pnode)
{
  replace_node_t* node;
  for (node = list->first; NULL != node; node = node->next) {
    if (pnode->info.raw_prototype.offset < node->offset) {
      return node;
    }
  }
  return NULL;
}

static replace_node_t* search_function_call(replace_list_t* list,
                                            symbol_usage_node_t* snode)
{
  replace_node_t* node;
  for (node = list->first; NULL != node; node = node->next) {
    if (snode->info.offset < node->offset) {
      return node;
    }
  }
  return NULL;
}

static replace_node_t* search_function_head(replace_list_t* list,
                                            symbol_usage_node_t* snode)
{
  replace_node_t* node;
  for (node = list->first; NULL != node; node = node->next) {
    if (snode->info.last_function_start < node->offset) {
      return node;
    }
  }
  return NULL;
}

static replace_node_t* new_replace_node(prototype_node_t* pnode,
                                        symbol_usage_node_t* snode,
                                        sort_search_t search)
{
  replace_node_t* node;

  if (NULL == (node = malloc(sizeof(*node)))) {
    error1("Out of memory while sorting usage list for '%s'",
           pnode->info.symbol);
    return NULL;
  }

  node->prev = node->next = NULL;
  node->prototype_node = pnode;
  node->symbol_usage_node = snode;
  node->search = search;
  node->offset = 0;
  if (NULL != pnode) {
    node->line = pnode->info.raw_prototype.line;
    node->column = pnode->info.raw_prototype.column;
  }
  else if (NULL != snode) {
    node->line = snode->info.line;
    node->column = snode->info.col;
  }

  return node;
}

static void replace_list_add(replace_list_t* list,
                             replace_node_t* node,
                             replace_node_t* new_node)
{
  if (NULL == list->first) {
    list->first = new_node;
  }

  if (NULL == node) {
    if (NULL != list->last) {
      list->last->next = new_node;
    }
    new_node->prev = list->last;
    list->last = new_node;
  }
  else {
    replace_node_t* prev = node->prev;

    if (NULL == prev) {
      list->first = new_node;
    }
    else {
      prev->next = new_node;
    }
    node->prev = new_node;
    new_node->prev = prev;
    new_node->next = node;
  }
}

static int insert_static_function_offset(replace_list_t* list,
                                         prototype_node_t* pnode)
{
  replace_node_t* new_node;
  replace_node_t* node;
  new_node = new_replace_node(pnode, NULL, SEARCH_STATIC_FUNCTION);
  if (NULL == new_node) {
    error0("Unable to create new sorted usage node");
    return -1;
  }

  node = search_static_function(list, pnode);

  new_node->offset = pnode->info.raw_prototype.offset;

  debug4(" Adding node \"%s\" static to replace list line: %lu column %lu (offset: %lu)", pnode->info.symbol, new_node->line, new_node->column, new_node->offset);

  replace_list_add(list, node, new_node);

  return 0;
}

static int insert_function_call_offset(replace_list_t* list,
                                       prototype_node_t* pnode,
                                       symbol_usage_node_t* snode)
{
  replace_node_t* new_node;
  replace_node_t* node;
  new_node = new_replace_node(pnode, snode, SEARCH_FUNCTION_CALL);
  if (NULL == new_node) {
    error0("Unable to create new sorted usage node");
    return -1;
  }

  node = search_function_call(list, snode);

  new_node->offset = snode->info.offset - strlen(pnode->info.symbol);

  debug4(" Adding node \"%s\" call to replace list line: %lu column %lu (offset: %lu)", pnode->info.symbol, new_node->line, new_node->column, new_node->offset);

  replace_list_add(list, node, new_node);

  return 0;
}

static int insert_calling_function_head_offset(replace_list_t* list,
                                               prototype_node_t* pnode,
                                               symbol_usage_node_t* snode)
{
  replace_node_t* new_node;
  replace_node_t* node;

  if (0 == snode->info.last_function_start) {
    return 0;
  }
  new_node = new_replace_node(pnode, snode, SEARCH_FUNCTION_HEAD);
  if (NULL == new_node) {
    error0("Unable to create new sorted usage node");
    return -1;
  }

  node = search_function_head(list, snode);

  new_node->offset = snode->info.last_function_start;

  debug4(" Adding node \"%s\" extern to replace list line: %lu column %lu (offset: %lu)", pnode->info.symbol, new_node->line, new_node->column, new_node->offset);

  replace_list_add(list, node, new_node);

  return 0;
}

static int sort_usage(replace_list_t* slist, prototype_list_t* plist) {
  prototype_node_t* pnode;
  /*
   * First add offsets to all the usage (function calls) to any function
   * that is supposed to have a generated proxy function. This is the actual
   * auto-mocking consequence. ALWAYS making sure that the design under test
   * use the proxy functions instead of the real functions.
   */

  for (pnode = plist->first; NULL != pnode; pnode = pnode->next) {
    symbol_usage_list_t* sl = &pnode->info.symbol_usage_list;
    symbol_usage_node_t* sn;
    debug1("Finding offset where to put the declaration for %s", pnode->info.symbol);
    for (sn = sl->first; NULL != sn; sn = sn->next) {
      debug3("  line: %lu column: %lu (offset: %lu)", sn->info.line, sn->info.col, sn->info.offset);
      if (insert_calling_function_head_offset(slist, pnode, sn)) {
        error0("Could not insert");
        return -1;
      }

      if (insert_function_call_offset(slist, pnode, sn)) {
        error0("Could not insert");
        return -1;
      }
    }
  }

  /*
   * Then add offets to all the statically declared functions in the pre-
   * processed source code version of the design under test, because these
   * must be made global instead of static in the output file, so that all
   * the modal functions in the design under test can be called from the
   * testcases.
   */
  for (pnode = plist->first; NULL != pnode; pnode = pnode->next) {
    if (pnode->info.linkage_definition.is_static) {
      debug1("Finding offset where to put the static declaration for %s", pnode->info.symbol);
      if (0 != insert_static_function_offset(slist, pnode)) {
        error0("Could not insert");
        return -1;
      }
    }
  }

  return 0;
}

void declarations_at_offset(prototype_list_t* list, const size_t insert_offset) {
  prototype_node_t* node;
  if (0 == insert_offset) {
    return;
  }
  for (node = list->first; NULL != node; node = node->next) {
    symbol_usage_list_t* slist = &node->info.symbol_usage_list;
    symbol_usage_node_t* snode;
    for (snode = slist->first; NULL != snode; snode = snode->next) {
      if (insert_offset == snode->info.last_function_start) {
        fprintf(stderr, "DEBUG: Should need to insert '%s' at %lu\n",
                node->info.symbol, insert_offset);
      }
    }
  }
}

static void generate_proxified(prototype_list_t* list, file_t* file) {
  /*
   * Replicate the pre-processed C code version and replace all function
   * calls with proxies, and also declare them extern right above the first
   * invoking function definition.
   */
  replace_list_t slist;
  replace_node_t* node;
  size_t offset = 0;
  slist.first = slist.last = NULL;
  if (0 != sort_usage(&slist, list)) {
    error0("Out of memory while sorting usage list\n");
    return;
  }

  for (node = slist.first; NULL != node; node = node->next) {
    offset = node->offset;
  }

  offset = 0;

  node = slist.first;
  while (offset < file->len) {
    if (NULL == node) {
      /* Write the rest of the file and exit */
      fwrite(&file->buf[offset], file->len - offset, 1, stdout);
      debug1("Writing %lu bytes chunk to end (file end)", file->len - offset);
      break;
    }
    else if (SEARCH_FUNCTION_HEAD == node->search) {
      fwrite(&file->buf[offset], node->offset - offset, 1, stdout);
      debug4("Writing %lu %lu %lu bytes chunk (before function head exetern %s)", offset, node->offset, node->offset - offset, node->prototype_node->info.symbol);
#ifdef VBCC
      printf("\n");
#endif
      generate_extern_proxy_prototype(list, offset, node);
      offset = node->offset;
    }
    else if (SEARCH_STATIC_FUNCTION == node->search) {
      /* Output all file contents since last offset increase */
      fwrite(&file->buf[offset], node->offset - offset, 1, stdout);
      debug4("Writing %lu %lu %lu bytes chunk (before static removal static %s)", offset, node->offset, node->offset - offset, node->prototype_node->info.symbol);
      offset = node->offset + strlen("static ") + 1;
    }
    else if (SEARCH_FUNCTION_CALL == node->search) {
      /* Output all file contents since last offset increase */
      fwrite(&file->buf[offset], node->offset - offset, 1, stdout);
      debug4("Writing %lu %lu %lu bytes chunk (before function call __tarsio_proxy %s)", offset, node->offset, node->offset - offset, node->prototype_node->info.symbol);
      printf("__tarsio_proxy_");
      offset = node->offset;
    }
    else {
      error0("This should never happen");
      exit(1);
    }
    node = node->next;
  }
}

/****************************************************************************
 * Program
 */
int main(int argc, char* argv[])
{
  int retval = EXIT_SUCCESS;
  tam_options_t options;
  file_t source_file = FILE_EMPTY;
  prototype_list_t prototype_list = PROTOTYPE_LIST_EMPTY;

  /*
   * Handle arguments passed to the program.
   */
  if (0 != tam_options_init(&options, argc, argv)) {
    retval = EXIT_FAILURE;
    goto options_init_failed;
  }

  /*
   * Read the pre-processed version of the design under test
   */
  if (0 != file_init(&source_file, options.source_filename)) {
    retval = EXIT_FAILURE;
    goto read_preprocessed_file_failed;
  }
  reload_symbol_cache(&prototype_list, options.cache_filename);

  /*
   * Generate a new version of the pre-processed input but with extern
   * declarations to all used function proxies, and replaced function
   * usage.
   */
  generate_proxified(&prototype_list, &source_file);

 read_preprocessed_file_failed:
 options_init_failed:
  return retval;
}
